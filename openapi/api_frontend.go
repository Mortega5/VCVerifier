/*
 * vcverifier
 *
 * Backend component to verify credentials
 *
 * API version: 0.0.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"net/http"
	"slices"

	"github.com/fiware/VCVerifier/logging"
	"github.com/fiware/VCVerifier/verifier"

	"github.com/gin-gonic/gin"
)

const DEFAULT_REQUEST_MODE = verifier.REQUEST_MODE_BY_REFERENCE

var frontendVerifier verifier.Verifier
var requestObjectClient *verifier.RequestObjectClient

func getFrontendVerifier() verifier.Verifier {
	if frontendVerifier == nil {
		frontendVerifier = verifier.GetVerifier()
	}
	return frontendVerifier
}

func getRequestObjectClient() *verifier.RequestObjectClient {
	if requestObjectClient == nil {
		requestObjectClient = verifier.NewRequestObjectClient()
	}
	return requestObjectClient
}

// VerifierPageDisplayQRSIOP - Presents a qr as starting point for the auth process
func VerifierPageDisplayQRSIOP(c *gin.Context) {

	state, stateExists := c.GetQuery("state")
	if !stateExists {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorMessageNoState)
		// early exit
		return
	}

	callback, callbackExists := c.GetQuery("client_callback")
	if !callbackExists {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorMessageNoCallback)
		// early exit
		return
	}

	clientId, clientIdExists := c.GetQuery("client_id")
	if !clientIdExists {
		logging.Log().Infof("Start a login flow for a not specified client.")
	}

	nonce, nonceExists := c.GetQuery("nonce")
	if !nonceExists {
		nonce = ""
	}

	requestMode, requestModeExists := c.GetQuery("request_mode")
	if !requestModeExists {
		logging.Log().Infof("Using default request mode %s.", DEFAULT_REQUEST_MODE)
		requestMode = DEFAULT_REQUEST_MODE
	}

	qr, err := getFrontendVerifier().ReturnLoginQR(c.Request.Host, "https", callback, state, clientId, nonce, requestMode)
	if err != nil {
		c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorMessage{"qr_generation_error", err.Error()})
		return
	}

	c.HTML(http.StatusOK, "verifier_present_qr", gin.H{"qrcode": qr})
}

// VerifierLoginQr - Presents a qr as starting point for the auth process
func VerifierLoginQr(c *gin.Context) {

	state, stateExists := c.GetQuery("state")
	if !stateExists {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorMessageNoState)
		// early exit
		return
	}

	redirectUri, redirectUriExists := c.GetQuery("redirect_uri")
	requestUri, requestUriExists := c.GetQuery("request_uri")

	if !redirectUriExists && !requestUriExists {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorMessageNoRedircetUri)
		// early exit
		return
	}

	clientId, clientIdExists := c.GetQuery("client_id")
	if !clientIdExists {
		logging.Log().Infof("Start a login flow for a not specified client.")
	}

	scope, scopeExists := c.GetQuery("scope")
	if !scopeExists {
		logging.Log().Infof("Start a login flow with default scope.")
		scope = ""
	}

	if requestUriExists {
		logging.Log().Debug("Requesting the client for its request object.")
		cro, err := getRequestObjectClient().GetClientRequestObject(requestUri)
		if err != nil {
			logging.Log().Warnf("Was not able to get request object. Err: %v", err)
			c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorMessageUnresolvableRequestObject)
			return
		}
		if !slices.Contains(cro.Aud, getFrontendVerifier().GetHost()) {
			c.AbortWithStatusJSON(http.StatusInternalServerError, ErrorMessageInvalidAudience)
			return
		}

		clientId = cro.ClientId
		scope = cro.Scope
		redirectUri = cro.RedirectUri
	}

	nonce, nonceExists := c.GetQuery("nonce")
	if !nonceExists {
		c.AbortWithStatusJSON(http.StatusBadRequest, ErrorMessageNoNonce)
		// early exit
		return
	}

	requestMode, requestModeExists := c.GetQuery("request_mode")
	if !requestModeExists {
		logging.Log().Infof("Using default request mode %s.", DEFAULT_REQUEST_MODE)
		requestMode = DEFAULT_REQUEST_MODE
	}

	qrInfo, err := getFrontendVerifier().ReturnLoginQRV2(c.Request.Host, "https", redirectUri, state, clientId, scope, nonce, requestMode)
	if err != nil {
		c.AbortWithStatusJSON(500, ErrorMessage{"qr_generation_error", err.Error()})
		return
	}

	c.HTML(http.StatusOK, "verifier_present_qr_v2", gin.H{"qrcode": qrInfo.QR, "wsUrl": getFrontendVerifier().GetHost() + "/ws?state=" + state, "qrExpireAt": qrInfo.ExpireAt.UnixMilli(), "qrDuration": qrInfo.TotalDuration})
}

// VerifierPageLoginExpired - Presents a page when the login session is expired
func VerifierPageLoginExpired(c *gin.Context) {
	c.JSON(http.StatusOK, gin.H{})
}
